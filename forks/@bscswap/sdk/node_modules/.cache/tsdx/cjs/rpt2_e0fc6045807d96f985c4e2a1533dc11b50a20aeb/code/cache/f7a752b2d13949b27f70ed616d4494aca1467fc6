{"code":"import { Contract } from '@ethersproject/contracts';\r\nimport { getNetwork } from '@ethersproject/networks';\r\nimport { getDefaultProvider } from '@ethersproject/providers';\r\nimport { TokenAmount } from './entities/fractions/tokenAmount';\r\nimport { Pair } from './entities/pair';\r\nimport IBSCswapPair from '@bscswap/contracts/build/IBSCswapPair.json';\r\nimport invariant from 'tiny-invariant';\r\nimport ERC20 from './abis/ERC20.json';\r\nimport { ChainId } from './constants';\r\nimport { Token } from './entities/token';\r\nlet TOKEN_DECIMALS_CACHE = {\r\n    [ChainId.MAINNET]: {\r\n        '0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A': 9 // DGD\r\n    }\r\n};\r\n/**\r\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\r\n */\r\nexport class Fetcher {\r\n    /**\r\n     * Cannot be constructed.\r\n     */\r\n    constructor() { }\r\n    /**\r\n     * Fetch information for a given token on the given chain, using the given ethers provider.\r\n     * @param chainId chain of the token\r\n     * @param address address of the token on the chain\r\n     * @param provider provider used to fetch the token\r\n     * @param symbol optional symbol of the token\r\n     * @param name optional name of the token\r\n     */\r\n    static async fetchTokenData(chainId, address, provider = getDefaultProvider(getNetwork(chainId)), symbol, name) {\r\n        const parsedDecimals = typeof TOKEN_DECIMALS_CACHE?.[chainId]?.[address] === 'number'\r\n            ? TOKEN_DECIMALS_CACHE[chainId][address]\r\n            : await new Contract(address, ERC20, provider).decimals().then((decimals) => {\r\n                TOKEN_DECIMALS_CACHE = {\r\n                    ...TOKEN_DECIMALS_CACHE,\r\n                    [chainId]: {\r\n                        ...TOKEN_DECIMALS_CACHE?.[chainId],\r\n                        [address]: decimals\r\n                    }\r\n                };\r\n                return decimals;\r\n            });\r\n        return new Token(chainId, address, parsedDecimals, symbol, name);\r\n    }\r\n    /**\r\n     * Fetches information about a pair and constructs a pair from the given two tokens.\r\n     * @param tokenA first token\r\n     * @param tokenB second token\r\n     * @param provider the provider to use to fetch the data\r\n     */\r\n    static async fetchPairData(tokenA, tokenB, provider = getDefaultProvider(getNetwork(tokenA.chainId))) {\r\n        invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID');\r\n        const address = Pair.getAddress(tokenA, tokenB);\r\n        const [reserves0, reserves1] = await new Contract(address, IBSCswapPair.abi, provider).getReserves();\r\n        const balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0];\r\n        return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]));\r\n    }\r\n}\r\n//# sourceMappingURL=fetcher.js.map","references":["/root/work/uniswap/SwapLiquidity-sdk/node_modules/@ethersproject/contracts/lib/index.d.ts","/root/work/uniswap/SwapLiquidity-sdk/node_modules/@ethersproject/networks/lib/index.d.ts","/root/work/uniswap/SwapLiquidity-sdk/node_modules/@ethersproject/providers/lib/index.d.ts","/root/work/uniswap/SwapLiquidity-sdk/src/entities/fractions/tokenAmount.ts","/root/work/uniswap/SwapLiquidity-sdk/src/entities/pair.ts","/root/work/uniswap/SwapLiquidity-sdk/node_modules/@bscswap/contracts/build/IBSCswapPair.json","/root/work/uniswap/SwapLiquidity-sdk/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","/root/work/uniswap/SwapLiquidity-sdk/src/abis/ERC20.json","/root/work/uniswap/SwapLiquidity-sdk/src/constants.ts","/root/work/uniswap/SwapLiquidity-sdk/src/entities/token.ts"],"map":"{\"version\":3,\"file\":\"fetcher.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/fetcher.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,0BAA0B,CAAA;AACnD,OAAO,EAAE,UAAU,EAAE,MAAM,yBAAyB,CAAA;AACpD,OAAO,EAAE,kBAAkB,EAAE,MAAM,0BAA0B,CAAA;AAC7D,OAAO,EAAE,WAAW,EAAE,MAAM,kCAAkC,CAAA;AAC9D,OAAO,EAAE,IAAI,EAAE,MAAM,iBAAiB,CAAA;AACtC,OAAO,YAAY,MAAM,4CAA4C,CAAA;AACrE,OAAO,SAAS,MAAM,gBAAgB,CAAA;AACtC,OAAO,KAAK,MAAM,mBAAmB,CAAA;AACrC,OAAO,EAAE,OAAO,EAAE,MAAM,aAAa,CAAA;AACrC,OAAO,EAAE,KAAK,EAAE,MAAM,kBAAkB,CAAA;AAExC,IAAI,oBAAoB,GAAyD;IAC/E,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;QACjB,4CAA4C,EAAE,CAAC,CAAC,MAAM;KACvD;CACF,CAAA;AAED;;GAEG;AACH,MAAM,OAAgB,OAAO;IAC3B;;OAEG;IACH,gBAAuB,CAAC;IAExB;;;;;;;OAOG;IACI,MAAM,CAAC,KAAK,CAAC,cAAc,CAChC,OAAgB,EAChB,OAAe,EACf,QAAQ,GAAG,kBAAkB,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,EAClD,MAAe,EACf,IAAa;QAEb,MAAM,cAAc,GAClB,OAAO,oBAAoB,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,QAAQ;YAC5D,CAAC,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC;YACxC,CAAC,CAAC,MAAM,IAAI,QAAQ,CAAC,OAAO,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,CAAC,QAAgB,EAAU,EAAE;gBACxF,oBAAoB,GAAG;oBACrB,GAAG,oBAAoB;oBACvB,CAAC,OAAO,CAAC,EAAE;wBACT,GAAG,oBAAoB,EAAE,CAAC,OAAO,CAAC;wBAClC,CAAC,OAAO,CAAC,EAAE,QAAQ;qBACpB;iBACF,CAAA;gBACD,OAAO,QAAQ,CAAA;YACjB,CAAC,CAAC,CAAA;QACR,OAAO,IAAI,KAAK,CAAC,OAAO,EAAE,OAAO,EAAE,cAAc,EAAE,MAAM,EAAE,IAAI,CAAC,CAAA;IAClE,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,KAAK,CAAC,aAAa,CAC/B,MAAa,EACb,MAAa,EACb,QAAQ,GAAG,kBAAkB,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QAEzD,SAAS,CAAC,MAAM,CAAC,OAAO,KAAK,MAAM,CAAC,OAAO,EAAE,UAAU,CAAC,CAAA;QACxD,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;QAC/C,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,GAAG,MAAM,IAAI,QAAQ,CAAC,OAAO,EAAE,YAAY,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC,WAAW,EAAE,CAAA;QACpG,MAAM,QAAQ,GAAG,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,CAAA;QAC7F,OAAO,IAAI,IAAI,CAAC,IAAI,WAAW,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,WAAW,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;IAC7F,CAAC;CACF\"}","dts":{"name":"/root/work/uniswap/SwapLiquidity-sdk/src/fetcher.d.ts","writeByteOrderMark":false,"text":"import { Pair } from './entities/pair';\r\nimport { ChainId } from './constants';\r\nimport { Token } from './entities/token';\r\n/**\r\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\r\n */\r\nexport declare abstract class Fetcher {\r\n    /**\r\n     * Cannot be constructed.\r\n     */\r\n    private constructor();\r\n    /**\r\n     * Fetch information for a given token on the given chain, using the given ethers provider.\r\n     * @param chainId chain of the token\r\n     * @param address address of the token on the chain\r\n     * @param provider provider used to fetch the token\r\n     * @param symbol optional symbol of the token\r\n     * @param name optional name of the token\r\n     */\r\n    static fetchTokenData(chainId: ChainId, address: string, provider?: import(\"@ethersproject/providers\").BaseProvider, symbol?: string, name?: string): Promise<Token>;\r\n    /**\r\n     * Fetches information about a pair and constructs a pair from the given two tokens.\r\n     * @param tokenA first token\r\n     * @param tokenB second token\r\n     * @param provider the provider to use to fetch the data\r\n     */\r\n    static fetchPairData(tokenA: Token, tokenB: Token, provider?: import(\"@ethersproject/providers\").BaseProvider): Promise<Pair>;\r\n}\r\n"}}
